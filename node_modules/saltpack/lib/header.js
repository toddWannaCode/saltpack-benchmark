// Generated by IcedCoffeeScript 108.0.11
(function() {
  var attached_sign_mode, compute_mac_key, crypto, crypto_auth_KEYBYTES, crypto_secretbox_KEYBYTES, current_major, current_minor, detached_sign_mode, encryption_mode, iced, make_esc, msgpack, nacl, nonce, util, __iced_k, __iced_k_noop;

  iced = require('iced-runtime');
  __iced_k = __iced_k_noop = function() {};

  crypto = require('crypto');

  msgpack = require('keybase-msgpack-lite');

  nacl = require('keybase-nacl');

  make_esc = require('iced-error').make_esc;

  nonce = require('./nonce');

  util = require('./util');

  encryption_mode = 0;

  attached_sign_mode = 1;

  detached_sign_mode = 2;

  current_major = 1;

  current_minor = 0;

  crypto_auth_KEYBYTES = 32;

  crypto_secretbox_KEYBYTES = 32;

  compute_mac_key = function(_arg, cb) {
    var encryptor, header_hash, mac_box, pubkey, zero_bytes;
    encryptor = _arg.encryptor, header_hash = _arg.header_hash, pubkey = _arg.pubkey;
    zero_bytes = new Buffer(crypto_auth_KEYBYTES);
    zero_bytes.fill(0);
    try {
      mac_box = encryptor.encrypt({
        plaintext: zero_bytes,
        nonce: nonce.nonceForMACKeyBox(header_hash),
        pubkey: pubkey
      });
    } catch (_error) {
      return cb(new Error("Failed to generate MAC keys"), null);
    }
    return cb(null, mac_box.slice(-crypto_auth_KEYBYTES));
  };

  exports.generate_encryption_header_packet = function(_arg, cb) {
    var anonymized_recipients, crypto_hash, encryptor, ephemeral_encryptor, esc, exposed_recipients, header_hash, header_intermediate, header_list, i, mac_keys, payload_encryptor, payload_key, rec_pair, rec_payload, recipients, recipients_list, sender_encryptor, sender_sbox, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _ref;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    encryptor = _arg.encryptor, recipients = _arg.recipients, anonymized_recipients = _arg.anonymized_recipients;
    esc = make_esc(cb, "generate_encryption_header_packet");
    header_list = [];
    header_list.push('saltpack');
    header_list.push([current_major, current_minor]);
    header_list.push(encryption_mode);
    payload_encryptor = nacl.alloc({
      force_js: false
    });
    payload_key = crypto.randomBytes(crypto_secretbox_KEYBYTES);
    payload_encryptor.secretKey = payload_key;
    ephemeral_encryptor = nacl.alloc({
      force_js: false
    });
    ephemeral_encryptor.genBoxPair();
    header_list.push(ephemeral_encryptor.publicKey);
    sender_encryptor = (encryptor != null ? encryptor.publicKey : void 0) != null ? encryptor : ephemeral_encryptor;
    sender_sbox = payload_encryptor.secretbox({
      plaintext: sender_encryptor.publicKey,
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    header_list.push(sender_sbox);
    recipients_list = [];
    if (!(recipients.length > 0)) {
      return cb(new Error("Bogus empty recipients list"), null);
    }
    exposed_recipients = (anonymized_recipients != null ? anonymized_recipients.length : void 0) === recipients.length ? anonymized_recipients : recipients;
    for (i = _i = 0, _ref = recipients.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      rec_pair = [];
      rec_pair.push(exposed_recipients[i]);
      rec_payload = ephemeral_encryptor.encrypt({
        plaintext: payload_key,
        nonce: nonce.nonceForPayloadKeyBox(),
        pubkey: recipients[i]
      });
      rec_pair.push(rec_payload);
      recipients_list.push(rec_pair);
    }
    header_list.push(recipients_list);
    crypto_hash = crypto.createHash('sha512');
    header_intermediate = msgpack.encode(header_list);
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    mac_keys = [];
    (function(_this) {
      return (function(__iced_k) {
        var _begin, _end, _j, _positive, _results, _step, _while;
        i = 0;
        _begin = 0;
        _end = recipients.length;
        if (_end > _begin) {
          _step = 1;
        } else {
          _step = -1;
        }
        _positive = _end > _begin;
        _while = function(__iced_k) {
          var _break, _continue, _next;
          _break = __iced_k;
          _continue = function() {
            return iced.trampoline(function() {
              i += _step;
              return _while(__iced_k);
            });
          };
          _next = _continue;
          if (!!((_positive === true && i >= recipients.length) || (_positive === false && i <= recipients.length))) {
            return _break();
          } else {

            (function(__iced_k) {
              __iced_deferrals = new iced.Deferrals(__iced_k, {
                parent: ___iced_passed_deferral,
                filename: "/home/mpcsh/keybase/node-saltpack/src/header.iced",
                funcname: "generate_encryption_header_packet"
              });
              compute_mac_key({
                encryptor: sender_encryptor,
                header_hash: header_hash,
                pubkey: recipients[i]
              }, esc(__iced_deferrals.defer({
                assign_fn: (function(__slot_1, __slot_2) {
                  return function() {
                    return __slot_1[__slot_2] = arguments[0];
                  };
                })(mac_keys, i),
                lineno: 69
              })));
              __iced_deferrals._fulfill();
            })(_next);
          }
        };
        _while(__iced_k);
      });
    })(this)((function(_this) {
      return function() {
        return cb(null, {
          header_intermediate: header_intermediate,
          header_hash: header_hash,
          mac_keys: mac_keys,
          payload_key: payload_key
        });
      };
    })(this));
  };

  exports.parse_encryption_header_packet = function(_arg, cb) {
    var crypto_hash, decryptor, ephemeral, error, esc, format, found, header_hash, header_intermediate, header_list, mac_key, major, minor, mode, payload_decryptor, payload_key, recipient_index, recipients, secret, sender, sender_pubkey, ___iced_passed_deferral, __iced_deferrals, __iced_k, _i, _j, _ref, _ref1, _ref2;
    __iced_k = __iced_k_noop;
    ___iced_passed_deferral = iced.findDeferral(arguments);
    decryptor = _arg.decryptor, header_intermediate = _arg.header_intermediate;
    esc = make_esc(cb, "parse_encryption_header_packet");
    crypto_hash = crypto.createHash('sha512');
    crypto_hash.update(header_intermediate);
    header_hash = crypto_hash.digest();
    header_list = msgpack.decode(header_intermediate);
    format = header_list[0], (_ref = header_list[1], major = _ref[0], minor = _ref[1]), mode = header_list[2], ephemeral = header_list[3], sender = header_list[4], recipients = header_list[5];
    if (format !== 'saltpack') {
      return cb(new Error("wrong format " + format), null);
    }
    if (major !== current_major) {
      return cb(new Error("wrong version number " + major + "." + minor), null);
    }
    if (mode !== encryption_mode) {
      return cb(new Error("packet wasn't meant for decryption, found mode " + mode), null);
    }
    secret = decryptor.box_beforenm({
      pubkey: ephemeral,
      seckey: decryptor.secretKey
    });
    found = false;
    payload_key = null;
    for (recipient_index = _i = 0, _ref1 = recipients.length; 0 <= _ref1 ? _i < _ref1 : _i > _ref1; recipient_index = 0 <= _ref1 ? ++_i : --_i) {
      if (recipients[recipient_index][0] === null) {
        continue;
      } else if (util.bufeq_secure(recipients[recipient_index][0], decryptor.publicKey)) {
        payload_key = decryptor.box_open_afternm({
          ciphertext: recipients[recipient_index][1],
          nonce: nonce.nonceForPayloadKeyBox(),
          secret: secret
        });
        found = true;
        break;
      }
    }
    if (!found) {
      for (recipient_index = _j = 0, _ref2 = recipients.length; 0 <= _ref2 ? _j < _ref2 : _j > _ref2; recipient_index = 0 <= _ref2 ? ++_j : --_j) {
        try {
          payload_key = decryptor.box_open_afternm({
            ciphertext: recipients[recipient_index][1],
            nonce: nonce.nonceForPayloadKeyBox(),
            secret: secret
          });
          if ((payload_key != null) || payload_key.length === 0) {
            break;
          }
        } catch (_error) {
          error = _error;
          if (error.message === 'TweetNaCl box_open_afternm failed!' || error.message === 'Sodium box_open_afternm failed!') {
            continue;
          } else {
            throw error;
          }
        }
      }
    }
    if (payload_key == null) {
      return cb(new Error('You are not a recipient!'), null);
    }
    payload_decryptor = nacl.alloc({
      force_js: false
    });
    payload_decryptor.secretKey = payload_key;
    sender_pubkey = payload_decryptor.secretbox_open({
      ciphertext: header_list[4],
      nonce: nonce.nonceForSenderKeySecretBox()
    });
    (function(_this) {
      return (function(__iced_k) {
        __iced_deferrals = new iced.Deferrals(__iced_k, {
          parent: ___iced_passed_deferral,
          filename: "/home/mpcsh/keybase/node-saltpack/src/header.iced",
          funcname: "parse_encryption_header_packet"
        });
        compute_mac_key({
          encryptor: decryptor,
          header_hash: header_hash,
          pubkey: sender_pubkey
        }, esc(__iced_deferrals.defer({
          assign_fn: (function() {
            return function() {
              return mac_key = arguments[0];
            };
          })(),
          lineno: 121
        })));
        __iced_deferrals._fulfill();
      });
    })(this)((function(_this) {
      return function() {
        return cb(null, {
          header_list: header_list,
          header_hash: header_hash,
          payload_key: payload_key,
          sender_pubkey: sender_pubkey,
          mac_key: mac_key,
          recipient_index: recipient_index
        });
      };
    })(this));
  };

}).call(this);
